# %%[markdown]

"""
# Projeto: Dashboard waze

Data: 22 junho 2021

Dataset: Traffic jams: traffic slowdown information generated by the service based on a
user’s location and speed. "Data provided by Waze App. Learn more at Waze.com".

Conteúdo: Leitura do Feed e criar arquivo .csv.

Metodologia da estrutura dos dados: Foram foram feitas associações espaciais para os
bairros da cidade, separação entre rodovias, área urbana e rural.
Também foi feita a adição de uma grade hexagonal de 250x250metros, a fim de
manter referência a seção viária.
"""

# %%

import datetime
from calendar import monthrange
import os
import json
import numpy as np
import pandas as pd
import geopandas as gpd
# import seaborn as sns
# import matplotlib.pyplot as plt

# pd.set_option('display.max_columns', 45)

# %%

# localização dados
dir_atual = os.getcwd()
# '/geo/www/mapas/waze'

local_base = '/geo/www/mapas/waze'

local_base_feed = f'{local_base}/resultados'
local_dados_aux = f'{local_base}/dados'
local_saida_dados = f'{local_base}/dados_exportados'
pastas_base_feed = os.listdir(local_base_feed)

# datas
data_hj = datetime.date.today()
hoje = data_hj.strftime('%Y-%m-%d')

num_anoatual = int(data_hj.strftime('%Y'))
num_mesatual = int(data_hj.strftime('%m'))

data_mes_passado = data_hj.replace(day=1) - datetime.timedelta(days=1)
num_anopassado = int(data_mes_passado.strftime('%Y'))
num_mespassado = int(data_mes_passado.strftime('%m'))

now = datetime.datetime.now()
now_primeiro_dia = now - datetime.timedelta(days=now.weekday())

# semana atual e passada
ultimas_semanas = {}

for n_week in range(2):
    ultimas_semanas[n_week] = [
        (now_primeiro_dia + datetime.timedelta(days=d-n_week*7)).strftime("%Y-%m-%d") for d in range(7)]

# %%
# carregar dados pasta feed


def pegar_mes(ano, mes, tipo):
    dias_mes = range(monthrange(ano, mes)[1]+1)[1:]
    dias = []
    for d in dias_mes:
        dias.append(f'{ano}-{mes:02}-{d:02}_{tipo}')

    dados_mes = []
    for f in dias:
        try:
            dados_mes.append(gpd.read_file(
                f'{local_base_feed}/{ano}/{tipo}/{f}.json'))
        except:
            print(f'dia {f} não encontrado')
    return gpd.GeoDataFrame(pd.concat(dados_mes, ignore_index=True),
                            crs=dados_mes[0].crs)

# %%


mes_atual_jams = pegar_mes(num_anoatual, num_mesatual, 'jams')
mes_passado_jams = pegar_mes(num_anopassado, num_mespassado, 'jams')

gdf = mes_passado_jams.append(mes_atual_jams)

print('união realizada')

# %%
# classe intervalohora

gdf['intervalohora'] = pd.cut(gdf['timestamp'].str[11:13].astype('int'),
                              [0, 6, 9, 12, 15, 18, 21, 24],
                              labels=['0-5', '6-8', '9-11', '12-14',
                                      '15-17', '18-20', '21-24'],
                              right=False)

gdf['dtdate'] = gdf['timestamp'].str.slice(0, 10)

gdf['hora'] = gdf['timestamp'].str[11:13].astype('int')

gdf['semana'] = np.where(
    gdf['dtdate'].isin(ultimas_semanas[0]), 'atual', np.where(
        gdf['dtdate'].isin(ultimas_semanas[1]), 'passada', 'outras'))

# %%
# organizar colunas

gdf = gdf.drop(columns=['country', 'segments', 'city', 'type',
                        'turnType', 'blockingAlertUuid', 'startNode'])

gdf['speed'] = np.round(gdf['speed'], decimals=2)
gdf['speedKMH'] = np.round(gdf['speedKMH'], decimals=2)

print('união espacial')

# %%
# articulação malha hexagonal

grade_hex_itj = gpd.read_file(f'{local_dados_aux}/grade_itj.shp')

gdf = gpd.overlay(
    gdf,
    grade_hex_itj,
    how='intersection')

# %%
# comprimento cortado pela malha hexagonal, em metros

gdf = gdf.to_crs(epsg=31982)
gdf['hexlength'] = gdf.length.apply(np.ceil).astype(int)

# %%
# delay cortado pela malha hexagonal, em m/s

gdf['hexdelay'] = (gdf['delay'] * gdf['hexlength']) / gdf['length']
gdf['hexdelay'] = gdf['hexdelay'].apply(np.ceil).astype(int)
gdf['hexdelay'] = np.where(gdf['delay'] == -1, -1, gdf['hexdelay'])

# %%

gdf = gdf.join(gdf['centroid'].str.split(',', 1, expand=True).rename(
    columns={0: 'lat', 1: 'long'}))

gdf = gdf[['nomebairro', 'regiao', 'uuid', 'delay', 'hexdelay', 'level',
           'dia_semana', 'semana', 'street', 'intervalohora', 'orientacao',
           'timestamp', 'dtdate', 'hora', 'length', 'hexlength', 'speedKMH', 'speed',
           'roadType', 'endNode', 'lat', 'long']]

# %%

gdf_semana = gdf.loc[gdf['semana'] != 'outras']

# %%[markdown]
# Descrição colunas
#
# nome          |descrição
# --------------|----
# codhexagon*   |código da célula hexagonal que compõe a grade espacial cobrindo a cidade.
# nomebairro*   |nome do bairro a que a seção pertence
# regiao*       |área no município ('urbana', 'rodovias', 'rural')
# uuid          |id da ocorrência
# delay         |atraso em relação ao fluxo normal, segundos (bloqueio do tráfego, -1)
# hexdelay*     |atraso relativo ao trecho do congestionamento sobre a célula hexagonal
# level         |nível de congestionamento (0 = nenhum 5 = bloqueio no tráfego)
# dia_semana*   |dia da semana da ocorrência
# street        |denominação da via segundo a base do google
# intervalohora*|intervalos em horas ('0-5','5-8','8-11','11-14','14-17','17-20','20-24')
# orientacao*   |direção do fluxo de tráfego
# timestamp*    |carimbo de data
# length        |comprimento do congestionamento em metros
# hexlength*    |comrimento relativo ao trecho sobre a célula hexagonal
# speedKMH*     |velocidade em Km/h
# speed         |velocidade em m/s
# roadType**    |tipo de via segundo a tabela tipo de via**
# endNode       |nome da via que pertence ao cruzamento mais próximo
# centroid*     |coordenadas do centróide da célula hexagonal, em wgs84(4326)
#
# * coluna criada na etapa de coleta/armazenamento
#
# ** Tabela roadType:
#
# código |tipo
# -------|----
# 1      |Streets
# 2      |Primary Street
# 3      |Freeways
# 4      |Ramps
# 5      |Trails
# 6      |Primary
# 7      |Secondary
# 8, 14  |4X4 Trails
# 15     |Ferry crossing
# 9      |Walkway
# 10     |Pedestrian
# 11     |Exit
# 16     |Stairway
# 17     |Private road
# 18     |Railroads
# 19     |Runway/Taxiway
# 20     |Parking lot road
# 21     |Service road

# %%
# progressão dias da semana atual e semana anterior

prog_dia_semana = gdf_semana.groupby(['semana',
                                      'dia_semana',
                                      'dtdate'],
                                     as_index=False)['hexdelay'
                                                     ].sum().sort_values('dtdate',
                                                                         ignore_index=True)

# plt.xticks(rotation=45)
# sns.barplot(x='dia_semana', y='hexdelay', hue='semana',
#             data=prog_dia_semana)

# %%
# progressão dia semana atual e anterior

dia_semana_hj = gdf_semana.loc[gdf_semana['dtdate'] == hoje,
                               :]['dia_semana'].values[0]

prog_dia = pd.DataFrame(gdf_semana.loc[gdf_semana['dia_semana'] == dia_semana_hj, :].groupby(['semana', 'hora'],
                                                                                             as_index=False)['hexdelay'].sum())

# sns.lineplot(x='hora', y='hexdelay', hue='semana',
#              data=prog_dia)

# %%
# ranqueamento 25 vias com maior atraso na faixa de horário atual (apenas área urbana)

ultima_hora = (datetime.datetime.now() - datetime.timedelta(hours=1)).hour
proxima_hora = (datetime.datetime.now() + datetime.timedelta(hours=1)).hour

rank_vias_urb = pd.DataFrame(gdf_semana.loc[(gdf_semana['hora'] >= ultima_hora) &
                                            (gdf_semana['hora'] <= proxima_hora) &
                                            (gdf_semana['regiao'] == 'urbana'), :]
                             .groupby(['street'], as_index=False)['hexdelay']
                             .sum()).sort_values('hexdelay',
                                                 ascending=False,
                                                 ignore_index=True).head(25)

# rank_vias_urb.head(30)

# %%
# ranqueamento bairros exetuando regioes rodovia, com maior atraso na faixa de horário atual (apenas área urbana)
# filter semana == atual && dia_seman == atual && fxhorario == atual groupby via .sum hexdelay

rank_bairros_urb = pd.DataFrame(gdf_semana.loc[(gdf_semana['hora'] >= ultima_hora) &
                                               (gdf_semana['hora'] <= proxima_hora) &
                                               (gdf_semana['regiao'] == 'urbana'), :]
                                .groupby(['nomebairro'], as_index=False)['hexdelay']
                                .sum()).sort_values('hexdelay',
                                                    ascending=False,
                                                    ignore_index=True).head(25)

# rank_bairros_urb.head(30)

# %%
# mapa, pontos zoom fixo

mapa = pd.DataFrame(gdf_semana.loc[(gdf_semana['hora'] >= ultima_hora) &
                                   (gdf_semana['hora'] <= proxima_hora), :]
                    .groupby(['lat', 'long', 'regiao', 'dtdate'], as_index=False)['hexdelay']
                    .sum()).sort_values('dtdate', ignore_index=True)

mapa = gpd.GeoDataFrame(
    mapa, geometry=gpd.points_from_xy(
        mapa['long'],
        mapa['lat']))

#mapa.loc[mapa['dtdate'] == hoje].plot()

# %%
# exportar arquivos webmap

# prog_dia_semana
prog_dia_semana.to_csv(
    f'{local_saida_dados}/prog_dia_semana.tsv', sep='\t')

# prog_dia
prog_dia.to_csv(f'{local_saida_dados}/prog_dia.tsv', sep='\t')

# rank_vias_urb
rank_vias_urb.to_csv(
    f'{local_saida_dados}/rank_vias_urb.tsv', sep='\t')

# rank_bairros_urb
rank_bairros_urb.to_csv(
    f'{local_saida_dados}/rank_bairros_urb.tsv', sep='\t')

# mapa
mapa.to_file(f'{local_saida_dados}/mapa.geojson',
             driver='GeoJSON')

# dados atualização

dados_atualizacao = {
    'datas_mapa': mapa['dtdate'].unique().tolist(),
    'data': hoje,
    'data_anterior': ultimas_semanas[1][ultimas_semanas[0].index(hoje)],
    'dia_semana_atual': dia_semana_hj,
    'horario': f'{now.hour}:{now.minute}',
    'intervalohora': f'{ultima_hora}-{proxima_hora}'
}

with open(f'{local_saida_dados}/dados_atualizacao.json', 'w') as f:
    json.dump(dados_atualizacao, f)

# %%
